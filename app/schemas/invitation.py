from pydantic import BaseModel, EmailStr, ConfigDict
from typing import Optional
from datetime import datetime
from app.models.invitation import InvitationStatus # Use the enum from the model

# Forward references for relationships if User and Startup schemas are in other files
# This is a common pattern. Adjust if your User/Startup schemas are imported directly.
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from app.schemas.user import User as UserSchema # Assuming User schema is named User
    from app.schemas.organization import Startup as StartupSchema # Assuming Startup schema is named Startup

# Properties to receive via API on creation
class InvitationBase(BaseModel):
    email: EmailStr
    startup_id: int
    # status will default to PENDING in model, not needed in base usually
    # expires_at will be set by the server
    # invitation_token will be generated by the server

class InvitationCreate(InvitationBase):
    approved_by_admin_id: int # Corp Admin who approved

# Properties to receive via API on update (e.g., admin resending or changing expiry)
# For now, we might only update status internally via token acceptance.
class InvitationUpdate(BaseModel):
    # Potentially status could be updated here by an admin (e.g., revoke)
    status: Optional[InvitationStatus] = None
    # Other fields if updatable, e.g., expires_at by an admin
    expires_at: Optional[datetime] = None

# Properties to receive via API on update - specific for marking accepted
class InvitationAccept(BaseModel):
    pass # For now, token in path is enough, user details will be separate step or pre-filled

# New schema for declining an invitation
class InvitationDecline(BaseModel):
    reason: Optional[str] = None
    model_config = ConfigDict(extra='forbid') # Ensure no extra fields are passed

# Schema for Corp Admin to directly invite a user to a startup
class CorpAdminDirectInviteCreate(BaseModel):
    email: EmailStr
    startup_id: int
    # approved_by_admin_id will be the current_user.id (Corp Admin)

# Base properties shared by models stored in DB
class InvitationInDBBase(InvitationBase):
    id: int
    invitation_token: str
    expires_at: datetime
    status: InvitationStatus
    approved_by_admin_id: Optional[int] = None # Was required in Create, but make optional in DB read
    accepted_at: Optional[datetime] = None
    accepted_by_user_id: Optional[int] = None
    revoked_at: Optional[datetime] = None
    revoked_by_admin_id: Optional[int] = None
    declined_at: Optional[datetime] = None # New field
    decline_reason: Optional[str] = None    # New field
    created_at: datetime # Added from model
    updated_at: datetime # Added from model

    model_config = ConfigDict(from_attributes=True)

# Additional properties to return to API
class Invitation(InvitationInDBBase):
    startup: Optional["StartupSchema"] = None # Populate with startup details
    approved_by_admin: Optional["UserSchema"] = None
    accepted_by_user: Optional["UserSchema"] = None
    revoked_by_admin: Optional["UserSchema"] = None

# Additional properties stored in DB
class InvitationInDB(InvitationInDBBase):
    pass

class InvitationListResponse(BaseModel):
    invitations: list[Invitation] 